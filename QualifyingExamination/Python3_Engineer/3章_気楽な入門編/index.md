# 3章_気楽な入門編
出題数 6問

## 1. 数値の取り扱い
#### 1-1. 四則演算
- 足し算(+)
`>>> 1 + 1` -> 2

- 引き算(-)
`>>> 2 - 1` -> 1

- 掛け算(*)
`>>> 2 * 2` -> 4

- 割り算(/)
`>>> 1 / 2` -> 0.5

- 剰余: 余りを求める(%)
`>>> 5 % 2` -> 1

#### 1-2. ちょっとだけ複雑な計算
- 複数の計算を同時に(*/ > +-)
`>>> 5 * 3 +2` -> 17

- 切り下げの割り算(小数点以下切り捨て)
`>>> 17 // 3` -> 3

- 累乗(**)
`>>> 2 ** 3` -> 8

#### 1-3. 変数を使った計算
`>>> a = 1`
`>>> b = 2`
`>>> a + b`
-> 1 + 2 -> 3

:::message alert
未定義の変数はNameErrorが表示される
:::

#### 1-4. 小数点の計算
`>>> 5 * 5 * 3.14`
-> 78.5

`>>> 7 / 2`
-> 3.5

#### 1-5. 四捨五入
**round()関数を使う**
- 通常の四捨五入
`>>> round(3.14)`
-> 3

- 小数点第一位で四捨五入する場合
`>>> round(3.14, 1)`
-> 3.1

## 2. 文字列の取り扱い
#### 2-1. 文字列の宣言
シングルクオーテーション or ダブルクオーテーションで囲む
`>>> 'hello'` or `>>> "hello"`

#### 2-2. クオーテーションを文字列ないで扱う
\ or ¥ で**エスケープ**する
`>>> 'dosen\'t'` -> "dosen't"

違うクオーテーションを利用する
`>>> "dosen't"` -> "dosen't"

#### 2-3. 特殊文字を使った改行, printで出力
改行 -> `\n`
改行を行いたい場合は`print()`を使用する。

`>>> 'First Line.\nSecond Line.'`
'First Line.\nSecond Line.'

`>>> print('First Line.\nSecond Line.')`
First Line.
Second Line.

#### 2-3. 特殊文字を使ったタブ, printで出力
タブ(インデント) -> `\t`
同じく`print()`を使用する。

`>>> 'abc\tdef'`
'abc\tdef'

`>>> print('abc\tdef')`
abc     def

#### 2-4. エスケープ文字そのものを表示したい
エスケープ文字をエスケープ or raw文字列として宣言
- エスケープシーケンスとraw文字列の理解
:::message
`\`に特定の文字を書くと特別に解釈される文字をエスケープシーケンスと呼ぶ。
raw文字列で使用する`r`, `R`はraw文字列を指定するためのリテラルである。
リテラルとは、Pythonのプログラムに直接記述された値のこと。`'hello'`の中の`hello`がリテラルに当たり、クオーテーションで囲む必要がある。
:::

1. エスケープ文字をエスケープする場合
`>>> 'abc\\tdef'`
'abc\tdef'

1. raw文字列として宣言
> raw文字列を使用すると`\`を1つの文字として扱うため、`\\`のように記述する必要がなくなる。
> 文字列の前に`r`または`R`を記述する

`>>> r'abc\tdef'`
'abc\\tdef'

#### 2-5. 複数行の文字列宣言
トリプルクオーテーション(シングルもしくはダブル)を使用する

```c
>>> '''
... First Line.
... Second Line.
... Third Line.
... '''
```
'\nFirst Line.\nSecond Line.\nThird Line.\n'

#### 2-6. 長い文字列の宣言
`()`を使用して、何行かに分けて記述することが出来る

```c
>>> ('長い文字列'
... 'をこんな風に宣言できます。')
```
'長い文字列をこんな風に宣言できます。'

#### 2-7. 文字列の結合と繰り返し
- `+`を用いて結合(結合部分の空白を1文字加える)
`>>> 'hello' + ' ' + 'world'`
'hello world'

- `*`を用いて文字列を繰り返す
`>>> 'hello' * 3`
'hellohellohello'

#### 2-8. n文字目の文字を取得
index番号はリストと同様

`>>> 'abcdefg'[0]`
'a'
`>>> 'abcdefg'[1]`
'b'
`>>> 'abcdefg'[-1]`
'g'

:::message alert
範囲外の文字を取得することは出来ない。
`>>> 'abcdefg'[10]`
> Traceback (most recent call last):
>   File "<stdin>", line 1, in <module>
> IndexError: string index out of range
:::

#### 2-9. 複数文字列の取得
1. `'abcdefg'[始まり:終わり]`

`>>> 'abcdefg'[0:2]`
'ab'
`>>> 'abcdefg'[0:3]`
'abc'
`>>> 'abcdefg'[1:3]` (1番目から3番目の1個手前まで)
'bc'

2. 始点や終点を省略した場合、以降全部となる

`>>> 'abcdefg'[0:]`
'abcdefg'
`>>> 'abcdefg'[1:]`
'bcdefg'
`>>> 'abcdefg'[:7]`(範囲外を指定してもエラーにはならない)
'abcdefg'
`>>> 'abcdefg'[5:7]`
'fg'

#### 2-10.文字列の長さを取得
`len()`関数で、文字列の長さを取得

`>>> len('abc')`
3
`>>> len('abcdef')`
6

#### 2-11. 文字列はn文字目を指定して変更は出来ない
1. 変数`moji`に文字列を代入
2. 文字列の0番目を`h`に変更するとする

`>>> moji = 'abcdefg'`
`>>> moji[0] = 'h'`
> Traceback (most recent call last):
>   File "<stdin>", line 1, in <module>
> TypeError: 'str' object does not support item assignment

この事を**変更不能体** または**immutable** という。


## 3. リストの取り扱い
- リストとは
  - 複数データをまとめて、順に並べたもの
    - 数字を並べる
    - 文字列を並べる
    - 辞書型のデータを並べる
    - などなど

#### 3-1.　リストの宣言方法
`>>> fibo = [1, 1, 2, 3, 5, 8]`
`>>> fibo`
[1, 1, 2, 3, 5, 8]

#### 3-2. リストのインデクシング
リストの一部を取得することを**インデクシング**という
- リスト名[何番目]で取得
`>>> fibo = [1, 1, 2, 3, 5, 8]`
`>>> fibo[0]`
1
`>>> fibo[2]`
2

インデクシング方法は文字列と同じ

#### 3-3.リストのスライシング
**スライシング**という操作でもリストの一部を取得することが出来る
- リスト名[始まり:終わり]

`>>> fibo = [1, 1, 2, 3, 5, 8]`
`>>> fibo[1:3]` (index1~3の1つ前まで)
[1, 2]
`>>> fibo[:-1]` (index最後の1つ前まで)
[1, 1, 2, 3, 5]
`>>> fibo[2:]`
[2, 3, 5, 8] (index2~)

スライシング方法は文字列と同じ

#### 3-4. リストのスライシングで代入(置き換え)
- リスト名[始まり:終わり] = 代入したいリスト

`>>> fibo = [1, 1, 2, 3, 5, 8]`
(index0~2番目の1つ前まで[0,1番]を-1,-2に変更する)
`>>> fibo[0:2] = [-1, -2]`
`>>> fibo`
[-1, -2, 2, 3, 5, 8] (1, 1 -> -1, -2に置き換えられている)

#### 3-5, リストのスライシングで削除
- リスト名[始まり:終わり] = []

`>>> fibo = [1, 1, 2, 3, 5, 8]`
(index0,1番を削除する)
`>>> fibo[0:2] = []`
`>>> fibo`
[2, 3, 5, 8] (1, 1が削除されている)

#### 3-6. リストの連結
`+`でリストを繋げる事が出来る

`>>> fibo = [1, 1, 2, 3, 5, 8]`
`>>> fibo + [13, 21, 24]`
[1, 1, 2, 3, 5, 8, 13, 21, 24]
(fiboリストの最後尾に13, 21, 24が連結されている)

#### 3-7. リストはn番目を指定して変更する事が出来る
fiboリストのn番目を指定して、変更することが可能

`>>> fibo = [1, 1, 2, 3, 5, 8]`
(index0を0に変更する)
`>>> fibo[0] = 0`
`>>> fibo`
[0, 1, 2, 3, 5, 8]

このことから、リストは**変更可能体(mutable)**である

#### 3-8. 末尾にデータを追加
`append()`メソッドを使う

`>>> fibo = [1, 1, 2, 3, 5, 8]`
`>>> fibo.append(13)`
`>>> fibo`
[1, 1, 2, 3, 5, 8, 13]

#### 3-9. リストの長さ
`len()`関数で長さを得られる

`>>> fibo = [1, 1, 2, 3, 5, 8]`
`>>> len(fibo)`
6

## 4. プログラミングを感じる
#### 4-1. フィボナッチ数列
```python: fibo.py
def main():
  a, b = 0, 1
  while b < 30:
    print(b)
    a, b = b, a + b

if __name__ == "__main__":
  main()
```

`fibo.py`があるディレクトリに移動し、`python fibo.py`
1
1
2
3
5
8
13
21

#### 4-1-1. `__name__`と`__main__`
- `__name__`とは
  - モジュールをインポートするとその`__name__`属性にモジュールの名前が文字列として格納される。
  - `<モジュール名>.__name__`で取得できる。

- `__main__`とは
  - ファイルをコマンドラインからスクリプトとして実行すると`__name__`には`__main__`という文字列が格納される。

#### 4-1-2. `if __name__ == "__main__"`の意味
まとめると、`__name__`に格納される値は以下の通り

:::message
他のファイルからインポートされた場合は`__name__`に`<モジュール名>`が格納される。
コマンドラインから`python`(または`python3`)コマンドで実行された場合は、`__name__`に`__main__`という文字列が格納される。
:::

したがって、`if __name__ == "__main__"`は、
**「該当ファイルがコマンドラインからスクリプトとして実行された場合にのみ、以降の処理を実行する」**という意味となる。
また、**他のファイルからインポートされたときは処理は実行されない**。

#### 4-1-3. 変数名を、書き方を変えてみる

```python: fibo.py
def main():
  a, b = 0, 1
  while b < 30:
    print(b)
    # a, b = b, a + b
    a_tmp = a
    a = b
    b = a_tmp + b

if __name__ == "__main__":
  main()
```

`a_tmp`を`a`の一時格納値としてプログラムを書き換える。
結果は同じだが、書き方を変えることでどういった処理が行われているか、見やすくなる。
