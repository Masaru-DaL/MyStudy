- [Python クラス入門](#python-クラス入門)
  - [キーワード](#キーワード)
- [Python クラス入門](#python-クラス入門-1)
  - [クラスを利用するメリット](#クラスを利用するメリット)
  - [クラスとは](#クラスとは)
  - [クラスの定義方法](#クラスの定義方法)
  - [インスタンスの作成（インスタンス化）と実行](#インスタンスの作成インスタンス化と実行)
  - [オブジェクトの種類](#オブジェクトの種類)
  - [メソッド](#メソッド)
    - [selfとは何か](#selfとは何か)
  - [コンストラクタ](#コンストラクタ)
  - [クラス変数とインスタンス変数](#クラス変数とインスタンス変数)
  - [まとめ](#まとめ)
# Python クラス入門

## キーワード

- Python
- class
- インスタンス
- オブジェクト
- self
- 入門

# Python クラス入門

この記事ではPythonのクラス入門編として、「クラスとは何か」に焦点を当てて解説します。実際にコードに触れながら説明していきますのでクラスに対する理解を深めていきましょう。

## クラスを利用するメリット

クラスについて学習する前に、クラスを利用すると何が嬉しいのかを段階に沿ってコードを書いていきます。**実行した結果は同じものが出力される点が重要です**。


## クラスとは

クラスを利用すると何が良いのか？と思うかもしれません。クラスは、必ず使わなければいけない！というわけではありません。**クラスを使用することは、リファクタリングを行うこと**でもあります。クラスを利用すると以下のようなメリットがあります。

- 似たようなコードを繰り返す書く必要がなくなる
- コードを再利用しやすい
- 機能を拡張しやすい

Python公式ドキュメントに、クラスに関して説明がされています。(参照先: [Python 3.11.0 Classes](https://docs.python.org/3/tutorial/classes.html#classes))

> クラスは、データと機能を束ねる手段を提供します。新しいクラスを作成すると、新しいタイプのオブジェクトが作成され、そのタイプの新しいインスタンスを作成することができるようになります。各クラスインスタンスは、その状態を保持するための属性を持つことができます。また、クラスのインスタンスは、その状態を変更するためのメソッド（クラスによって定義される）を持つことができます。

コーディングの内容を掴みながらの方が「クラスとは何か」を理解しやすいです。そのため、上述した内容と、それを理解するのに必要な事について、Pythonでクラスの定義やクラスに関するコーディングを実際に行いながら説明していきます。

## クラスの定義方法

- クラス定義: 構文ルール

```python:
# <>内は自身で実装する

class <クラス名称>:

    <クラスの実装内容>
```

- 構文ルールに則ったクラス定義の一例

```python:
class TestClass:

    print("Hello World!!")
```

上記のように、`class`に続けてクラス名、処理を記述するだけでクラス定義ができます。Pythonのクラス名は**CapWords 方式**（**アッパーキャメルケース**）で記述するという命名規則がありますので、単語の先頭を大文字にしてクラス名を付ける点に注意しましょう。([Python コーディング規約 PEP 8: クラスの名前](https://pep8-ja.readthedocs.io/ja/latest/#section-26))

## インスタンスの作成（インスタンス化）と実行

インスタンスの作成は、**クラスからオブジェクトを生成すること**です。クラスは「設計書」のようなもので、クラスという設計書を基にして何か（オブジェクト）を作成していきます。

> クラスは、データと機能を束ねる手段を提供します。

このように、クラスはあくまで手段を提供するだけで、**クラスを定義しただけではまだ実際に何も作られていない**ということです。インスタンスを作成は以下のように行います。

```python:
class TestClass:
    print("Hello World!!")

# インスタンスの作成
test1 = TestClass()
test2 = TestClass()

# インスタンスの実行
test1 # 実行結果: Hello World!!
test2 # 実行結果: Hello World!!
```

上記のように、「`インスタンス = クラス名()`」とするだけでインスタンスの作成が簡単にできます。また、同じクラスから複数のインスタンスを作成することも可能です。

## オブジェクトの種類

Pythonはオブジェクト指向のプログラミング言語です。オブジェクト指向とは、**データやそれを扱う処理（ソースコード）をまとめて「オブジェクト（物）」として扱う考え方のこと**です。

オブジェクトは**さまざまな実体の総称**を指し、インスタンスは**クラスを元に作成したオブジェクトの実体のこと**を指します。以下の図のようにオブジェクト指向言語ではインスタンスもオブジェクトの一部として扱うので、オブジェクトとインスタンスは同じものを指しています。

**クラスとインスタンスの図**

クラスには、クラスオブジェクトと、インスタンスオブジェクトが存在します。前の節で、`test1 = TestClass()`で`test1`というインスタンスを作成しました。インスタンスの作成元の`TestClass`には**クラスオブジェクト**が代入されていて、`test1`には**インスタンスオブジェクト**が代入されています。

- クラスオブジェクト

クラスオブジェクトは、**クラス定義を抜けると生成されるオブジェクトのこと**です。これは以下の文のことを意味します。
> 新しいクラスを作成すると、新しいタイプのオブジェクトが作成され、そのタイプの新しいインスタンスを作成することができるようになります

- インスタンスオブジェクト

インスタンスオブジェクトは、**クラスオブジェクトからインスタンス化されたもの**を指します。

**クラスオブジェクトとインスタンスオブジェクト**

## メソッド

メソッドは簡単に言うと、**クラス内に定義された関数**のことをメソッドと呼びます。関数とメソッドの違いは以下のようになります。

```python:
# 関数
def test_class_function():
    print("Hello World!!")


class TestClass:
    # メソッド
    def test_class_method():
        print("Hello World!!")
```

関数をクラスの中で定義するとメソッドと呼ばれますが、通常の関数とメソッドで異なる点が1点あります。それは、**メソッドは必ず1つ以上の引数を持つ**ということです。(参照: [Python3.11.0 Method Objects](https://docs.python.org/3/tutorial/classes.html#method-objects))なので、上記のメソッドの例は引数に何も指定していないので、厳密なメソッドの定義から外れています。

メソッドを定義する際には、必ず`self`という引数を指定する必要があります。`self`は必ずしも`self`でなければいけないというわけではないのですが、Pythonエンジニアの慣例として`self`がデファクトスタンダードになっています。他の人にも理解できるように、基本的には`self`と記述するようにしましょう。
引数に`self`を指定した、正しいメソッドの定義とメソッドの呼び出しが以下になります。

```python:
class TestClass:
    # 正しいメソッドの定義
    def test_class_method(self):
        print("Hello World!!")

# インスタンス化
instance = TestClass()

# メソッドの呼び出し
instance.test_class_method()

# 実行結果: Hello World!!
```

### selfとは何か

なぜメソッドに`self`として引数を指定する必要があるのかは理由があります。その理由を、以下のようにクラスの中に2つのメソッドを定義した例から説明していきます。

```python:
class TestClass:
    # test_method1: 引数messageの値を表示する
    def test_method1(self, message):
        print(message)

    # test_method2: test_method1を呼び出す
    def test_method2(self):
        self.test_method1("Hello self!!")

# インスタンス化
instance = TestClass()

# メソッドの呼び出し
instance.test_method2()

# 出力 -> Hello self!!
```

上の`test_method1`は第1引数に`self`を指定し、2つ目の引数に`message`を指定し、その`message`を出力する処理を定義しています。

下の`test_method2`は、先ほど定義した`test_method1`を呼び出すメソッドを定義しています。実行する処理に注目して頂きたいのですが、`self.test_method1("Hello self!!")`の部分です。
メソッドの呼び出しには必ず「`インスタンス名 .メソッド名()`」という形でインスタンを指定する必要があります。インスタンス化するのはクラスを基にして行うので、**クラス内ではまだインスタンスが作成されていません**。そこで、**クラス内で別のメソッドを呼び出したい時に仮のインスタンスとして役割を担うのが`self`です**。つまり、`self`はそのクラス自身を表しているということです。

`self.test_method1("Hello self!!")`を分かりやすく説明すると、このクラスの中の、`test_method1`の引数に`"Hello self!!`を指定して呼び出す。ということになります。

## コンストラクタ

コンストラクタとは、**オブジェクトが生成される時に一度だけ実行されるメソッドのこと**です。

- コンストラクタの構文ルール

```python:
# <>内は自身で実装する
def __init__(self, <引数1>, <引数1>, <引数n>)

    <実行する処理>
```

コンストラクタは`__init__`（initの前後に`_`（アンダーバー）が2つ）という名前で固定です。コンストラクタの概念の理解のために、一度通常のメソッド呼び出しを見てみましょう。

```python:
class TestClass:
    def __init__(self):
        self.year = 2022
        self.greeting = "Hello Constructor!!"

instance = TestClass()

print(instance.year)
print(instance.greeting)

# 出力結果: 2022
# 出力結果: Hello Constructor!!
```

メソッド定義にコンストラクタを使用していますが、この時点ではコンストラクタである必要はありませんが理解のためにコンストラクタを使用しています。
コンストラクタで`year`と`greeting`を宣言し、その中身を表示する内容です。インスタンスが作成された時点で変数に値が格納されています。
次に、以下のコードを見てみましょう。

```python:
class TestClass:
    greeting = "Hello World!!" # 初期値: Hello World!!
    def __init__(self):
        self.year = 2022
        self.greeting = "Hello Constructor!!"

instance = TestClass()

print(instance.year)
print(instance.greeting)

# 出力結果: 2022
# 出力結果: Hello Constructor!!
```

`greeting`の初期値を設定していますが、インスタンス化して最終的に出力された`greeting`はコンストラクタで格納した値になっています。これは、**インスタンスが呼び出された時点（`instance.greeting`が実行された時点）で自動的にコンストラクタが実行される**からです。これがコンストラクタの概念です。

## クラス変数とインスタンス変数

クラスの中で利用できる変数は、大きく2種類に分けられます。1つは**クラス変数**で、もう1つが**インスタンス変数**です。

- クラス変数
クラス変数とは、**クラス内で定義する変数のこと**です。クラス内で定義した変数の値は、**全てのインスタンスで共通の値**を参照します。

```python:
class TestClass:
    morning = "Good Morning!!" # クラス変数
    def greeting(self):
        print(self.morning)

instance1 = TestClass()        # インスタンス1
instance1.greeting()

instance2 = TestClass()        # インスタンス2
instance2.greeting()

# 実行結果: Good Morning!!
# 実行結果: Good Morning!!
```

上記の`morning`がクラス変数に当たります。異なるインスタンス（インスタンス1およびインスタンス2）でも同じ結果が出力されます。

- インスタンス変数
インスタンス変数は、**インスタンス化したインスタンスオブジェクトごとに定義された変数のこと**です。インスタンスオブジェクトごとに定義した変数は、**インスタンスごとに異なる値を変数に指定**することができます。

```python:
class TestClass:
    # コンストラクタ
    def __init__(self, greeting):
        # 引数greetingの値をインスタンス変数の初期値とする
        self.greeting = greeting

# 引数greetingに「Hello!!」を渡す
instance1 = TestClass("Hello!!")
print(instance1.greeting)

# 引数greetingに「Good Evening!!」を渡す
instance2 = TestClass("Good Evening!!")
print(instance2.greeting)

# 実行結果: Hello!!
# 実行結果: Good Evening!!
```

上記のように、インスタンス変数はメソッドの直下で`self`の値として定義します。それぞれインスタンス化する際に渡した値が異なるので、出力結果も異なります。

- 属性
ここまで行ってきて、クラス変数はクラスオブジェクトが持つ値、インスタンス変数は、インスタンスオブジェクトが持つ値ということが分かりました。このようなオブジェクトが持つ値のことは**属性**と呼ばれます。これが以下の文のことを意味します。

> 各クラスインスタンスは、その状態を保持するための属性を持つことができます。

インスタンスはメソッドを利用し、属性を変更することができます。その例を以下に挙げます。

```python:
class TestClass:
    # コンストラクタ
    def __init__(self):
        # 引数greetingの値をインスタンス変数の初期値とする
        print("Hello World!!")

    def wave_hands(self):
        print("手を振る")

    def walk(self):
        print("歩く")

instance1 = TestClass() # インスタンス化
# ここで実行するとコンストラクタの"Hello World!!"のみが出力する

instance1.wave_hands()  # instance1が手を振るようになる
# この時点で実行すると"Hello World!!"と"手を振る"が出力される

instance1.walk()        # instance1がさらに歩くようになる
# 最終的に"Hello World!!"、"手を振る"、"歩く"が出力される
```

今回はイメージのために全て出力処理ですが、インスタンス化したinstance1の状態がメソッドを持たせることで段々と変化しているのが分かります。これが以下の文のことを意味します。

> クラスのインスタンスは、その状態を変更するためのメソッド（クラスによって定義される）を持つことができます。

## まとめ

今回はPythonの「クラスとは何か」に焦点を当てて解説しました。

実際にクラスを利用した際の利点を活かすためには、クラスの種類や特徴などを押さえなければなりません。今回の記事は「クラスの入門部分」しか解説していませんが、クラスの根幹部分であり、一番大切な部分です。

こちらの記事でしっかりと「クラスとは何か」を理解し、コードのリファクタリングを行っていきましょう。
