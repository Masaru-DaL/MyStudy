# 構造化データの読み込みにまつわる問題
Webアプリケーションでは、XMLやJSONなどの構造を持ったデータを扱うことがよくある。
これらのデータ形式は、アプリケーション内部のデータ構造を保存したり外部に伝送したりする場合によく用いられる。
構造をもったデータを保存や伝送に適したバイト列に変換することをシリアライズと呼ぶ。
シリアライズやその周辺の技術にまつわる処理に起因する脆弱性には以下がある
- evalインジェクション
- 安全でないデシリアライゼーション
- XXE

# evalインジェクション
## 概要
構造をもったデータの例として、プログラムのソースコードを用いるケースがある。
最近よく用いられるJSONはJavaScriptのソースコードの形式を一部切り出したものが起源ですし、その他の言語でも、ソースコード解釈実行するevalと呼ばれる機能や関数があり、各言語のソースコードをデータとして扱うことができる。
evalの利用法に問題がある場合、外部から送り込んだスクリプトを実行される場合がある。
このような攻撃をevalインジェクション攻撃と呼び、そのような攻撃を受ける脆弱性をevalインジェクション脆弱性と呼ぶ
evalインジェクションによる影響は以下の通り
- 情報漏洩
- サイト改ざん
- 不正な機能実行
- 他サイトへの攻撃(踏み台)
- 暗号通貨の採掘(マイニング)

## 脆弱性が生まれる原因
- evalを用いることがそもそも危険である
- evalに与えるパラメータのチェックがされていない

## 対策
###  eval(同等機能を含む)を使わない
- シリアライズの目的である場合、以下の選択肢がある
  - implode/explode
    - implode関数は配列を引数としてとり、区切り記号をはさんで文字列にする関数
    - explodeはその逆を行う
    - 単純な配列のシリアライズには対応できる
  - json_encode/json_decode
    - 自由度と安全性のバランスから多くの場合に推奨できる方法
  - serialize/unserialize
    - serializeはさらに自由度が高く、オブジェクトのシリアライズが可能
    - しかし、「安全でないデシリアライゼーション」の原因になるので避けるべき
- シリアライズ以外の目的でも、evalなどを使わない実装を検討すべき
  - 多くの場合eval相当の機能を使わなくても、同等の処理は実装可能である
  - 例えば、e修飾子つきのpreg_replaceの代わりにpreg_replace_callbackを使うと安全である
###  evalの引数に外部からのパラメータを指定しない
evalを使った場合でも外部からパラメータを指定できなければ攻撃はできない。
ただし、スクリプトの注入経路はHTTPリクエスト経由だけとは限らず、ファイルやデータベース経由で注入できる場合もあるので、そのような注入経路の可能性がある場合は、この対策方法は使えない。
### evalの与える外部からのパラメータを英数字に制限する
外部から与えるパラメータを英数字に限定できれば、スクリプトの注入に必要な記号文字(セミコロンのほか、コンマ、引用符など多種)が使えなくなるので、スクリプト注入はできなくなる。

## まとめ
evalは強力な機能であるがゆえに、脆弱性が混入した場合の影響も甚大である。
世の中にはevalのない言語も多く存在するわけで、極力evalを使わない実装が推奨される。

# 安全でないデシリアライゼーション
## 概要
- シリアライゼーション
  - アプリケーション内部の構造を持ったデータを保存・伝送する目的でバイト列に変換すること
- デシリアライゼーション
  - シリアライズされたデータから元のデータに戻すこと
シリアライズとデシリアライズは、コンテンツ管理システム(CMS)やアプリケーションフレームワークの内部ではよく用いられるが、シリアライズされたデータが信頼出来ない場合、デシリアライズ処理の際に意図しないオブジェクトがアプリケーション内に生成され、場合によっては任意のコードを実行されてしまう場合がある
影響は以下の通り
- 情報漏洩
- サイト改ざん
- 不正な機能実行
- 他サイトへの攻撃(踏み台)
- 暗号通貨の採掘(マイニング)

## 脆弱性が生まれる原因
- 外部からの信頼できない入力データを元にデシリアライズ処理を行うと、意図しないオブジェクトがメモリ上に生成される
  - オブジェクトはメソッドを持っているので、攻撃者はオブジェクトのプロパティを巧妙に設定することにより、任意のコードを外部から実行出来る場合がある

## 対策
安全でないデータをデシリアライズすることは基本的に危険であり、避けなければならない
対策としては以下が考えられる
- シリアライズ形式ではなくJSON形式によりデータを受け渡す
- クッキーやhiddenパラメータではなくセッション変数など書き換えできない形でシリアライズ形式のデータを受け渡す
- HMACなどの改ざん検知の仕組みを導入してデータが改ざんされていないことを確認する

# XML外部実体参照(XXE)
## 概要
XMLには外部実体参照という機能があり、外部ファイルの内容を取り込むことができる。
XMLデータを外部から受け取るプログラムは、外部実体参照の形でWebサーバ内部のファイルなどを不正に読み取られる可能性がある。
この攻撃をXML実体参照攻撃と呼び、XML外部実体参照ができてしまう脆弱性をXML外部実体参照脆弱性と呼ぶ。
※XML外部実体参照という用語は長いので、XXE(XML External Entity)と省略する。

## 脆弱性が生まれる原因
XMLの外部実体参照を使うとXML中に外部のファイルを流し込むことが出来ることはXMLが元々持つ機能。
従って、XXEはXMLの機能を悪用するものであり、プログラムにコーディング上のバグがあるというものではない。

## 対策
XXEはXMLの機能を悪用するものなので、外部実体参照を禁止する指定を行うことが基本となる。
PHPの場合以下のいずれかの方法でXXE対策が可能。
### XMLの代わりにJSONを用いる
外部から与えられた信頼できないXMLを解析しないことでXXE対策となる。
しかし、XMLは外部とのデータ交換に用いられることも多いため、単にXMLの受け取りをやめるというのは難しい場合がある。
このため、外部とのデータ交換には、XMLの代わりにJSONを用いる方が安全である。
JSONの場合、安全でないデシリアライゼーションやXXEなどの問題は通常発生しない。
ただし、SOAPのようにプロトコルでXMLを採用している場合には、XMLをやめるわけにはいかないので、以下の外部実体参照を禁止する方法で対策する。
### libxml2のバージョン2.9以降を用いる
PHPのXML処理には、内部でlibxml2というライブラリが用いられている。
libxml2の2.9以降では、デフォルトで外部実体参照を停止する設定となっており、XXEに対して脆弱ではない。
ただし、PHP側で外部実体参照を許可する設定にしている場合は例外となる。
※メジャーなLinuxディストリビューションに関して、サポート継続中、かつ最新のパッチを適用していれば、libxml2側で外部実体参照を停止していることが確認されている。
### libxml_disable_entity_loader(true)を呼び出す
PHPにはlibxml_disable_entity_loaderという関数が用意(PHP5.2.11以降)されていて、これを呼び出すことにより、libxml2やPHP側の処理内容に関わらず外部実体参照が禁止される。

## まとめ
XXEが最初に報告されたのが2002年なので、かなり古くから知られている問題だが、これまで大きく取り上げられることはなかった。
しかし、OWASP TOP10の2017年版に4番目のリスクとしてランクインしたことにより大きな注目を集めることになる。
PHPを使う限り、libxml2のバージョンアップあるいはパッチ適用に対策されるが、Java言語の場合アプリケーション側での対策が必要となるため、PHP以上に注意が必要である。
