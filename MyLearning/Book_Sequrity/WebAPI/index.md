# WebAPI実装における脆弱性
近年のWebアプリケーションではWebAPIが多く用いられる。
WebAPIは通常のWebアプリケーションとは異なり、様々な機能の処理を実行した上で表示用の画面ではなくデータのみを返すものである。
WebAPIの利用が盛んになった拝啓としては、アプリケーション開発においてJavaScriptの重要性が増加したことや、スマホアプリと通信して機能を提供するサーバ側の実装携帯として適していることが挙げられる。
WebAPIで用いるデータ形式としてはもともとXMLが用いられましたが、その後JSONという形式が考案され、広く用いられている。
WebAPIで生じやすい脆弱性は以下の通り
- JSONエスケープの不備
- JSON直接閲覧によるXSS
- JSONPのコールバック関数名によるXSS
- WebAPIのクロスサイトリクエストフォージェリ
- JSONハイジャック
- JSONPの不適切な利用
- CORSの検証不備

# JSONとJSONPの概要
## JSONとは
WebAPIで用いられるAjax(Asynchronous JavaScript + XML)は、その名が示すようにもともとXMLをデータの受け渡しに使っていたが、XMLは表現がやや冗長であるという課題があった。
このため、XMLに代わるデータ交換形式として、JavaScriptのオブジェクトリテラルの形式が注目され、これをデータ交換形式に発展させたものがJSON(JavaScriptObject Notation; ジェイソン)である。
JSONは、基本的にはJavaScriptの式として解釈できるため、JSONが考案された当初はJavaScriptのeval関数によりJSON文字列をJavaScriptのデータ形式に変換していた。しかし、この方法は危険であるため、以下の安全な方法が用意されている。
### サーバ側のJSONとオブジェクトの相互変換(PHP)
- json_encode
  - PHPの配列・オブジェクトからJSON文字列を生成
- json_decode
  - JSON文字列をPHPの配列に変換
### JavaScript側のJSONとオブジェクトの相互変換
- JSON.stringify
  - JavaScriptのオブジェクトからJSON文字列を生成
- JSON.parse
  - JSON文字列をJavaScriptのオブジェクトに変換

## JSONPとは
JavaScriptのXMLHttpRequestは、もともと同一オリジンポリシーの制約があり、異なるオリジンからのデータを取得できないという課題があった。
この課題を解決するためにCORSが規定されたが、CORSができる前に同一オリジンポリシーの枠内で異なるオリジンのサーバからデータを取得するいくつかの方法が考案され、用いられていた。
その代表的な方法の1つがJSONP(JSON with Padding)である。
JSONPは、XMLHttpRequestではなく、script要素を用いて外部のJavaScriptを直接実行することによりデータを取得する。
そのためにはJSON文字列そのままではscript要素で受け取ることができないので、関数呼び出しの形でデータを生成する。

# JSONエスケープの不備
## 概要
APIにおいてJSON文字列生成時のエスケープ処理に不備があると、意図しないJavaScriptがJSONデータに混入する場合がある。
JSONデコードにeval関数を使っている場合や、JSONPのようにscript要素でJSON文字列を読み込んでいる場合は、不正なJavaScriptの実行に至る。

## 脆弱性が生まれる原因
- JSON文字列の生成時に適切なエスケープ処理などが行われていない
- JSONの評価にeval関数などを用いているか、JSONPを用いている

## 対策
- 文字列連結によるJSONデータ生成をやめ、信頼できるライブラリを用いてJSONを生成する
- eval関数ではなくJSON.parseなどの安全なAPIでJSONを解釈する
### 保険的な対策
- JSONPを避け、CORSを用いたWebAPIに移行する

# JSON直接閲覧によるXSS
## 概要
JSONを返すWebAPIは、通常XMLHttpRequestによるアクセスを想定したものだが、APIが返すレスポンスデータをブラウザで直接閲覧させることにより攻撃が可能になる場合がある。

## 脆弱性が生まれる原因
JSONを直接表示することによるXSSは、MIMEタイプの間違いが直接の原因であると言える。

## 対策
### MIMEタイプを正しく設定する(必須)
- JSONを出力する限り、セキュリティ以前の問題として必須であり、セキュリティ上も重要である。
### レスポンスヘッダX-Content-Type-Options: nosniffを出力する(強く推奨)
- セキュリティ強化のために有効であり、JSON以外の様々なMIMEタイプに有用であるため、常に出力しておくことが推奨される。
### 小なり記号などをUnicodeエスケープする(推奨)
- この方法は簡単に実装でき、他の対策が万一漏れた場合の保険的な対策としても有効であり、かつ副作用もないので、実施することが推奨される。
### XMLHttpRequestなどCORS対応の機能だけから呼び出せるようにする(推奨)
- JSON直接表示によるXSS対策だけであれば、必ずしもここまでチェックする必要はないが、X-Requested-WithヘッダのチェックによりJSONハイジャックなどの対策にもなるので、実施が推奨される。

# JSONPのコールバック関数名によるXSS
## 概要
JSONPはJSONデータを引数とするコールバック関数呼び出しの形式をとるが、このコールバック関数の名前は固定ではなく外部から指定できるようにするケースが多い。外部から指定したパラメータにより表示内容(関数名)が制御できることから、コールバック関数名によるクロスサイトスクリプティングが可能になる場合がある。

## 脆弱性が生まれる原因
- 外部から指定されたコールバック関数名を検証しないでそのまま表示している
- MIMEタイプをtext/javascriptとするべきところをtext/htmlとしている

## 対策
コールバック関数名によるXSSは、脆弱性が生まれる原因のうち片方をなくせば攻撃はできなくなるはずだが、正しいプログラムを書くという観点からは以下の両方を実施すべきである。
過去に異常に長いコールバック関数名を用いた攻撃方法が指摘されたことがあるので、文字数についての制限も重要である。
### コールバック関数名の文字種と文字数を制限する
コールバック関数名はJavaScriptの識別子なので、まずはJavaScriptの識別子の仕様に従う必要がある。
JavaScriptの識別子には広範囲の文字が使えるが、現実には英数字とアンダースコアのみに制限しても問題はないと思われる。
これにより攻撃に必要な小なり記号などが使用できなくなるので、攻撃を回避できる。
### MIMEタイプを正しく設定する
JSONPのMIMEタイプはtext/javascriptなので、JSONPを返すAPIもMIMEタイプとしてはtext/javascriptを返すべきである。
この場合は、ブラウザはレスポンスをHTMLとして解釈しないので、script要素は解釈されず、JavaScriptとしての実行もされない。

# WebAPIのクロスサイトリクエストフォージェリ
CSRFは一般的な画面を持つページだけではなく、WebAPIでもCSRF脆弱性は混入する。

## 攻撃経路のまとめ
WebAPIに対するCSRF攻撃には様々な経路があるが、主要なものとしてはHTMLフォームによるものとXMLHttpRequestによるものがある。
WebAPIが要求するリクエストの形式(MIMEタイプ)により、攻撃の難易度が変わるが、現実のWebアプリケーションの多くがHTTPリクエストのMIMEタイプを検証していないので、CSRF攻撃ができてしまうWebAPIはかなり多い印象である。

## 対策
WebAPIに対するCSRF対策はトークンによる方法が使えるので、これを第一選択肢とすべきだが、WebAPI固有の事情により他の方法が使われる場合もある。
代表的な方法は以下の通り
### CSRFトークン(セッション変数にトークンを保持)
これは乱数によるトークンをセッション変数に保存するとともに、hiddenパラメータなどで送信し、受け取り側でセッション変数と比較するものである。
Webページと同じ方法が使える事がメリットだが、API呼び出しのJavaScriptにトークンを渡す方法が問題になる。
具体的には以下の方法がある。
- Webページにhiddenパラメータやカスタムデータ属性で保存し、JavaScriptから参照する
- CSRFトークンを返すAPIを用意する
どの方式を採用するかは、実装のしやすさで判断してよい。
### 二重送信クッキー
これは乱数によるトークンをクッキーとして保存しておき、同じ値をリクエストヘッダのパラメータとしてクッキーとは別に送信する方法である。
結果としてクッキーともう1つのヘッダで同じ値が送信されることから、二重送信クッキーと呼ばれる。
#### 二重送信クッキーの問題点
クッキーは第三者から強制される可能性があり、主な経路としては下記がある。
- クッキーモンスターバグ
- 対象サイトおよび対象サイトのサブドメインにXSS脆弱性がある場合
- 通信路上からHTTPにて強制
攻撃者がサイト利用者のクッキーを変更できる状況では、攻撃者は適当に生成したトークンをサイト利用者のクッキーに強制した上で、同じ値をトークンパラメータとして送信することで、CSRF対策を回避できる。
この対策として、トークンに電子署名をつける方法も考えられるが、攻撃者は攻撃対象サイトにアクセスして自分用のトークンを取得し、それを攻撃に使うことで回避できる。
さらにこの攻撃の対策も可能だが、二重送信クッキーの持つ特徴(実装が簡便で、サーバ側で状態を保持する必要がない)を損なう可能性がある。
この問題の緩和のためにも、トークンパラメータの送信にHTTPリクエストヘッダを用いることが推奨される。
クロスオリジン通信でカスタムリクエストヘッダを付与するためには、プリフライトリクエストで許可される必要があるため、API側のプリフライトリクエストの処理にバグがなければCSRF攻撃は成立しない。
### カスタムリクエストヘッダによる対策
JavaScriptのライブラリの中には、Ajaxリクエストに自動的にカスタムリクエストヘッダを付与するものがある。
これが付与されていることをサーバ側で確認することだけでもCSRF対策になる。
この方法はCSRF以外の脆弱性に対する攻撃を広範囲に防ぐことができるので、保険的な対策としても実施が推奨される。
上記の方法でCSRF対策できるはずだが、この方法には懸念点もあった。
AdobeFlashPlayerを使うと、カスタムヘッダを許可なく送信できる脆弱性が過去に存在していたためである。
すなわち、Flashコンテンツによる罠を作れば、カスタムリクエストヘッダによるCSRF対策を回避できたことになる。
しかし、この脆弱性は2014年7月には修正されているので、今後新たな脆弱性が見つからない限りはこの方法でCSRF対策として十分ということになる。
### 加えて、共通の対策として以下を実施する。
- 入力データのMIMEタイプ(application/jsonなど)を検証する
- CORSを適切に実装する

## 結局どの方法を採用すればいいのか
確認だが、WebAPI向けのCSRF対策としては以下の方法がある
- CSRFトークン
- 二重送信クッキー
- HTTPリクエストヘッダによる方法
安全性という点では、セッション変数にトークンを保持したCSRFトークン方式がもっとも優れており、ついで二重送信クッキーによる方法、HTTPリクエストヘッダによる方法となる。
可能な限り安全な方式の採用が推奨される。

# JSONハイジャック
## 概要
JSONデータでscript要素で受け取ることはできず、JSONPはJSONをコールバック関数の引数にすることで、アプリケーションからデータを受け取れる形にしている。
しかし、なんらかの方法でJSONデータをscript要素で受け取ることができないかが研究されており、その手法はJSONハイジャックと呼ばれる。
脆弱性対策の責任分担としては、JSONハイジャックはブラウザが対策すべきものと考えられるが、過去にJSONハイジャックができる脆弱性が複数報告されていることから、アプリケーション側でもJSONハイジャック対策をしておいたほうが好ましいと言える。

## 対策
概要の通り、アプリケーション側での対策が推奨される。
有効な方法としては下記がある。
- X-Content-Type-Options: nosniffヘッダの付与(強く推奨)
- リクエストヘッダX-Requested-With: XMLHttpRequestの確認(推奨)

# JSONPの不適切な利用
JSONPは、もともとAjaxの同一オリジンポリシーの制限をすり抜けるために考案されたという事情もあり、使い方を間違えると簡単に脆弱性に直結してしまうという問題がある。
このため、JSONPは極力使用をやめ、CORS対応のAPIに移行することが望ましい。

## JSONPによる秘密情報提供
JSONPにはCORSのようなアクセス制御の仕組みがないため、JSONPによる情報公開は公開情報の提供にとどめ、秘密情報の提供は避けるべきである。

## 脆弱性が生まれる原因
JSONPには呼び出し元のオリジンに対する制御の機能がないことが原因。
本来のサイトと罠サイトのそれぞれから呼び出されるJSONPリクエストは、Refererのみが異なっていて、他は同一となっている。
Refererヘッダは常に送信されるとは限らないため、アクセス制御に用いるのは適切ではない。

## 対策
JSONPをやめ、CORS対応のXMLHttpRequestを用いることであり、もはや、JSONPを用いるべき積極的な理由はないからである。
現実には、まだJSONPを使うWebサイトは多いのでJSONP利用に伴う脆弱性を解説しているが、できるだけ早期にJSONPをやめて、CORSを用いた実装に移行すべき。

## 信頼できないJSONP APIの使用
JSONPは異なるオリジンのAPIをscript要素で呼び出すため、API側に悪意があった場合に、その悪意を緩和する手立てがない。
仮にAPI提供側に悪意があると任意のJavaScriptがアプリケーションのオリジン実行されるため、クロスサイトスクリプティングと同等のリスクとなる。
一方、XMLHttpRequestの場合は、スクリプトの内容にもよるが、多くの場合、間違った情報を表示するだけで任意JavaScriptの実行までは許さずに済む。
JSONPは出来るだけ避けるべきではあるが、やむを得ずJSONPを採用する場合でもAPI提供元が信頼できる組織である場合に限るべきである。

## まとめ
JSONPは今後新規開発では使用せずCORSに移行することが推奨される。
- JSONPはできるだけ使用せずCORS＋JSONに移行する
- JSONPは公開情報の提供のみに用いる
- JSONPは信頼できる提供元のみを使用する

# CORSの検証不備
CORSは非常によく考えられた仕様で、素直にこれを使う限りはオリジンに関する問題が起きる余地はない。
しかし、利用者側の無知や手抜きなどにより問題が起こる場合はある。
これはどのようなセキュリティ機構についても起こり得ることである。

# セキュリティを強化するレスポンスヘッダ
WebAPIに限らないが、HTTPレスポンスヘッダとして常に出力しておくだけでブラウザのセキュリティ機能を強化する仕組みが用意されている。
代表的なのが以下
### X-Frame-Options
これを指定すると、frameやiframeの内部に表示することができなくなり、クリックジャッキングやiframeなどを用いた他の攻撃を防止する。
### X-Content-Type-Options
X-Content-Type-Options: nosniffという形で使用する。
これによりブラウザはMIMEタイプの解釈を厳密にすることで、MIMEタイプをブラウザに誤認させるタイプの攻撃や、JSONハイジャック攻撃などを緩和する。
### X-XSS-Protection
モダンなブラウザの多くにはXSSフィルタと呼ばれるセキュリティ機能が実装されている。(ただしFirefoxは例外でXSSフィルタが実装されていない)
X-XSS-Protectionヘッダは下記の2点の役割がある。
- 利用者がXSSフィルタの有効化・無効化設定をしていても、当該ページについてXSSフィルタの設定を上書きする
- XSSフィルタの動作モードを指定する
### Content-Security-Policy
Content-Security-Policyは、主にクロスサイトスクリプティング攻撃を緩和するためのセキュリティ機能としてブラウザに実装されつつある。
CSPはうまく利用することができればXSS攻撃を大幅に緩和できる防御策として期待されるが、一方開発側の労力も大きいため、残念ながらまだあまり普及していないようである。
JavaScriptのセキュリティ機能としての期待度は高いため、CSPの同行を注視することが推奨される。
### Strict-Transport-Security(HTTP Strict-Transport-Security; HSTS)
HTTP Strict-Transport-SecurityはHTTPSでの接続を強制するための指令である。
サイトアクセスをHTTPSのみにすることが一般的になってきた。
この施策は「常時TLS」と呼ばれる場合がある。
サイトアクセスをHTTPSに限るための一般的な実装では、HTTPアクセスをHTTPSにリダイレクトすることが行われるが、この際、中間者攻撃により、HTTPアクセスをHTTPにダウングレードされるリスクが残る。
HSTSのレスポンスヘッダが設定されていると、ブラウザは当該ホストへの接続を一定期間HTTPSアクセスに強制するため、上記ダウングレード攻撃のリスクを緩和できる。
ただし、HSTSをいったん指定すると、HTTPS
HTTPSをやめることが難しくなることや、事故署名証明書など信頼できない証明書が使えなくなるというデメリットもあるため、HSTSは計画的な導入が推奨される。

# まとめ
非常に多くの脅威があるように受け取られるかもしれないが、対策の多くは共通のものであり、対策に著しく手間がかかるということはない。
WebAPIが急速に普及したのに対して、その脆弱性対策の知識は普及が遅れているので、CORSその他の基礎知識を理解した上で、脆弱性対策を進めることが求められる。
